# Build Process

## The Golden Rule

```
╔═══════════════════════════════════════════════════════════════════════╗
║  ALWAYS use `wasm-pack build` or `scripts/build-all.sh`               ║
║  NEVER use `cargo build` directly for WASM crates                     ║
╚═══════════════════════════════════════════════════════════════════════╝
```

---

## The Build Pipeline (Step by Step)

### Step 1: Source Code

```
examples/solar-system/src/
├── lib.rs      (WASM entry points)
├── game.rs     (Game logic)
└── *.rs        (Other modules)
```

### Step 2: wasm-pack build

```bash
wasm-pack build examples/solar-system --target web --out-dir pkg
```

This command does THREE things internally:

```
┌─────────────────────────────────────────────────────────────────────┐
│  wasm-pack build                                                     │
│                                                                      │
│  1. cargo build --target wasm32-unknown-unknown --release            │
│     └── Produces: target/.../solar_system.wasm                       │
│                                                                      │
│  2. wasm-bindgen (generates JS glue code)                            │
│     └── Produces: pkg/solar_system.js                                │
│     └── Produces: pkg/solar_system_bg.wasm                           │
│                                                                      │
│  3. wasm-opt (optimizes the WASM binary)                             │
│     └── Optimizes: pkg/solar_system_bg.wasm                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Step 3: Output (pkg/ folder)

```
examples/solar-system/pkg/
├── solar_system_bg.wasm    # Compiled WASM binary
├── solar_system.js         # JavaScript bindings (imports/exports)
├── solar_system.d.ts       # TypeScript definitions
└── package.json            # NPM package metadata
```

### Step 4: Vite Dev Server

```bash
npm run dev
```

Vite serves files with this priority:
1. `public/` folder (HIGHEST - avoid putting pkg files here!)
2. Project root (where `examples/*/pkg/` lives)

### Step 5: Browser Execution

```
Browser                           Server
   │                                │
   ├─── GET /examples/.../pkg/solar_system.js ───►
   │◄────────────────────────────────┤
   │                                │
   │  solar_system.js runs:         │
   │  WebAssembly.instantiate(      │
   │    solar_system_bg.wasm,       │
   │    { imports }                 │
   │  )                             │
   │                                │
   ├─── GET /examples/.../pkg/solar_system_bg.wasm ─►
   │◄────────────────────────────────┤
   │                                │
   │  WASM loaded, game runs        │
   └────────────────────────────────┘
```

---

## Why Direct cargo build Is Wrong

When you run `cargo build --target wasm32-unknown-unknown` directly:

| Step | What Happens | Problem |
|------|--------------|---------|
| 1 | Cargo compiles Rust to WASM | WASM expects imports like `__wbg_log_ABC123` |
| 2 | Nothing | JS bindings NOT regenerated |
| 3 | Old JS still has `__wbg_log_XYZ789` | **MISMATCH** |

The WASM binary and JS bindings contain **hash-based function names**. These hashes are generated by `wasm-bindgen` based on:
- Function signatures
- wasm-bindgen version

If you compile WASM without regenerating JS, the hashes don't match:

```
WASM imports:  __wbg_log_6b5ca2e6124b2808  ← new hash
JS exports:    __wbg_log_24aba2a6d8990b35  ← old hash

Result: LinkError: function import requires a callable
```

`wasm-pack build` runs BOTH cargo and wasm-bindgen together, guaranteeing the hashes match.

---

## Build Commands Reference

### Development: Build One Example

```bash
wasm-pack build examples/solar-system --target web --out-dir pkg
```

### Production: Build Everything

```bash
bash scripts/build-all.sh
```

This script:
1. Runs `wasm-pack build` for ALL example crates
2. Runs `npm install`
3. Runs `vite build`
4. Copies WASM packages and static assets to `dist/`

### Type Checking Only (Safe)

```bash
cargo check --target wasm32-unknown-unknown
```

This does NOT produce artifacts, only checks types. Safe to run anytime.

---

## Command Safety Reference

| Command | Safe? | Why |
|---------|-------|-----|
| `wasm-pack build examples/foo --target web --out-dir pkg` | ✅ YES | Builds WASM + JS together |
| `bash scripts/build-all.sh` | ✅ YES | Builds everything correctly |
| `cargo check --target wasm32-unknown-unknown` | ✅ YES | Type check only, no artifacts |
| `cargo build --target wasm32-unknown-unknown` | ❌ NO | Builds WASM without JS bindings |
| `cargo build --release` | ❌ NO | Same problem |

---

## The public/ Pitfall

Vite serves files from `public/` with **highest priority**. If stale WASM/JS files exist in `public/examples/`, they override freshly built files.

**Rule:** Never put pkg files in `public/`. The `.gitignore` excludes `public/examples/`.

---

## Nuclear Reset (When Everything Is Broken)

If you see `LinkError: function import requires a callable`:

```bash
# 1. Delete all build artifacts
cargo clean
rm -rf examples/*/pkg
rm -rf public/examples
rm -rf dist
rm -rf node_modules/.vite

# 2. Rebuild everything
bash scripts/build-all.sh

# 3. Restart dev server
pkill -f vite
npm run dev
```

---

## Troubleshooting

### Error: `LinkError: function import requires a callable`

**Cause:** WASM and JS have mismatched function hashes.

**Fix:** Rebuild with wasm-pack:
```bash
wasm-pack build examples/THE_BROKEN_EXAMPLE --target web --out-dir pkg
```

### Error: Changes not appearing in browser

**Cause:** Vite serving cached/stale files.

**Fix:**
```bash
rm -rf node_modules/.vite
rm -rf public/examples
# Restart dev server
```

### Error: Example missing from build

**Cause:** Example not listed in `scripts/build-all.sh`.

**Fix:** Add it to the `CRATES` array in `scripts/build-all.sh`.
